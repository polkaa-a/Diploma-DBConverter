package conversion.dtotodto.mongotopostgres;

import conversion.dtotodto.DTOToDTOConverter;
import conversion.types.PostgresSQLTypesConverter;
import conversion.types.enums.PostgreSQLTypes;
import dto.mongodb.MongoDBDatabaseDTO;
import dto.mongodb.MongoDBDocumentDTO;
import dto.mongodb.MongoDBFieldDTO;
import dto.postgresql.PostgreSQLDatabaseDTO;
import dto.postgresql.PostgreSQLFieldDTO;
import dto.postgresql.PostgreSQLForeignKeyDTO;
import dto.postgresql.PostgreSQLTableDTO;
import org.bson.BsonType;

import java.util.Set;
import java.util.stream.Stream;

import static data.mongodb.ConstantsProvider.DOC_ID_COLUMN_NAME;
import static data.postgresql.ConstantsProvider.*;

public abstract class MongoDBDTOToPostgreSQLDTOConverter
        implements DTOToDTOConverter<MongoDBDatabaseDTO, PostgreSQLDatabaseDTO> {

    protected Set<PostgreSQLTableDTO> tables;

    protected void makeTableFromDocument(MongoDBDocumentDTO documentDTO) {
        var documentId = documentDTO.getDocument().get(DOC_ID_COLUMN_NAME);
        var collectionName = documentDTO.getMongoDBCollectionDTO().getName();
        var tableName = collectionName + NAME_DELIMITER + documentId;
        initTable(documentDTO, tableName);
    }

    protected void makeTableFromSubDocument(MongoDBDocumentDTO subDocumentDTO, String tableName) {
        var table = initTable(subDocumentDTO, tableName);
        var field = new PostgreSQLFieldDTO(ID_COLUMN_NAME, PKCOLUMN_TYPE, true, null, table);
        field.setAutogeneratedFlag();
        table.addField(field);
    }

    protected void makeTableFromDocumentOrAddAsSource(MongoDBDocumentDTO documentDTO) {
        var compatibleTable = findCompatibleTable(documentDTO);
        if (compatibleTable == null) {
            makeTableFromDocument(documentDTO);
        } else {
            addAsSource(compatibleTable, documentDTO);
        }
    }

    protected void makeTableFromSubDocumentOrAddAsSource(MongoDBDocumentDTO subDocumentDTO, String tableName) {
        var compatibleTable = findCompatibleTable(subDocumentDTO);
        if (compatibleTable == null) {
            makeTableFromSubDocument(subDocumentDTO, tableName);
        } else {
            addAsSource(compatibleTable, subDocumentDTO);
        }
    }

    private PostgreSQLTableDTO initTable(MongoDBDocumentDTO documentDTO, String tableName) {
        var table = new PostgreSQLTableDTO(tableName);
        table.addSource(documentDTO);
        getDocumentFieldsThatCanBeMapped(documentDTO).forEach(fieldDTO -> addFieldDTO(table, fieldDTO));
        tables.add(table);
        return table;
    }

    protected boolean isCompatible(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        var optionalSource = tableDTO.getSources().stream().findAny();
        if (optionalSource.isEmpty()) return false;
        var source = (MongoDBDocumentDTO) optionalSource.get();
        var sourceCollectionName = source.getMongoDBCollectionDTO().getName();
        var documentCollectionName = documentDTO.getMongoDBCollectionDTO().getName();
        return sourceCollectionName.equals(documentCollectionName);
    }

    protected void addAsSource(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        tableDTO.addSource(documentDTO);
    }

    protected final PostgreSQLTableDTO findCompatibleTable(MongoDBDocumentDTO documentDTO) {
        var table = tables.stream().filter(tableDTO -> isCompatible(tableDTO, documentDTO)).findAny();
        return table.orElse(null);
    }

    // TODO: Рекурсия
    protected PostgreSQLFieldDTO addFieldDTO(PostgreSQLTableDTO tableDTO, MongoDBFieldDTO fieldDTO) {
        var fieldName = fieldDTO.getOriginalName();
        var fieldType = fieldDTO.getBsonType();
        var convertedType = PostgresSQLTypesConverter.convert(fieldType);
        if (fieldType.equals(BsonType.DOCUMENT)) {
            var relTableName = tableDTO.getOriginalName() + NAME_DELIMITER + fieldName;
            var fk = new PostgreSQLForeignKeyDTO(relTableName, ID_COLUMN_NAME);
            var document = fieldDTO.getMongoDBDocumentDTO();
            var subDocument = document.getSubDocuments().get(fieldDTO.getOriginalName());
            var newFieldName = getFKFieldName(fieldName);
            var field = new PostgreSQLFieldDTO(newFieldName, convertedType, fieldDTO.isId(), fk, tableDTO);
            tableDTO.addField(field);
            makeTableFromSubDocumentOrAddAsSource(subDocument, relTableName);
            return field;
        } else {
            var field = new PostgreSQLFieldDTO(fieldName, convertedType, fieldDTO.isId(), null, tableDTO);
            tableDTO.addField(field);
            return field;
        }
    }

    protected Stream<MongoDBFieldDTO> getDocumentFieldsThatCanBeMapped(MongoDBDocumentDTO documentDTO) {
        return documentDTO.getFields().stream().filter(f -> PostgresSQLTypesConverter.convert(f.getBsonType()) != null);
    }

    protected void updateSimilarFields(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        for (var docField : getDocumentFieldsThatCanBeMapped(documentDTO).toList()) {
            var name = docField.getOriginalName();
            var type = PostgresSQLTypesConverter.convert(docField.getBsonType());
            var similarFields = getSimilarFields(tableDTO, name, type);
            if (!similarFields.toList().isEmpty()) {
                similarFields.forEach(f -> f.setNewName(getMarkedFieldName(f)));
                var field = addFieldDTO(tableDTO, docField);
                field.setNewName(getMarkedFieldName(field));
            }
        }
    }

    protected void updateNewFields(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        for (var docField : documentDTO.getFields()) {
            var name = docField.getOriginalName();
            var type = PostgresSQLTypesConverter.convert(docField.getBsonType());
            var similarFields = getSimilarFields(tableDTO, name, type);
            var identicalFields = getIdenticalFields(tableDTO, name, type);
            if (identicalFields.toList().isEmpty() && similarFields.toList().isEmpty()) {
                addFieldDTO(tableDTO, docField);
            }
        }
    }

    protected Stream<PostgreSQLFieldDTO> getFilteredFields(PostgreSQLTableDTO tableDTO, String name) {
        var fieldsExcludeAutogenerated = tableDTO.getFields().stream().filter(f -> !f.isAutogenerated());
        return fieldsExcludeAutogenerated.filter(f -> f.getOriginalName().equals(name) ||
                (f.getFK() != null && f.getOriginalName().equals(getFKFieldName(name))));
    }

    protected Stream<PostgreSQLFieldDTO> getSimilarFields(PostgreSQLTableDTO tableDTO, String name, PostgreSQLTypes type) {
        var filteredFields = getFilteredFields(tableDTO, name);
        return filteredFields.filter(f -> !f.getType().equals(type));
    }

    protected Stream<PostgreSQLFieldDTO> getIdenticalFields(PostgreSQLTableDTO tableDTO, String name, PostgreSQLTypes type) {
        var filteredFields = getFilteredFields(tableDTO, name);
        return filteredFields.filter(tableField -> tableField.getType().equals(type));
    }
}

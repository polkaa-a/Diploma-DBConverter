package conversion.dtotodto.mongotopostgres;

import conversion.dtotodto.DTOToDTOConverter;
import conversion.dtotodto.mongotopostgres.data.RelTable;
import conversion.types.PostgresSQLTypesConverter;
import conversion.types.enums.PostgreSQLTypes;
import dto.mongodb.MongoDBDatabaseDTO;
import dto.mongodb.MongoDBDocumentDTO;
import dto.mongodb.MongoDBFieldDTO;
import dto.postgresql.PostgreSQLDatabaseDTO;
import dto.postgresql.PostgreSQLFieldDTO;
import dto.postgresql.PostgreSQLForeignKeyDTO;
import dto.postgresql.PostgreSQLTableDTO;
import exceptions.ConversionException;
import org.bson.BsonType;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Stream;

import static data.mongodb.ConstantsProvider.DOC_ID_COLUMN_NAME;
import static data.postgresql.ConstantsProvider.*;

public abstract class MongoDBDTOToPostgreSQLDTOConverter
        implements DTOToDTOConverter<MongoDBDatabaseDTO, PostgreSQLDatabaseDTO> {

    protected Set<PostgreSQLTableDTO> tables;

    public PostgreSQLDatabaseDTO convert(MongoDBDatabaseDTO mongoDBDatabaseDTO) throws ConversionException {
        tables = new HashSet<>();
        for (var collection : mongoDBDatabaseDTO.getCollections()) {
            for (var documentDTO : collection.getDocuments()) makeTableFromDocumentOrAddAsSource(documentDTO);
        }
        return new PostgreSQLDatabaseDTO(mongoDBDatabaseDTO.getName(), tables);
    }

    protected void makeTableFromDocumentOrAddAsSource(MongoDBDocumentDTO documentDTO) throws ConversionException {
        var compatibleTable = findCompatibleTableForDocument(documentDTO);
        if (compatibleTable == null) makeTableFromDocument(documentDTO);
        else addDocumentAsSource(compatibleTable, documentDTO);
    }

    protected void makeTableFromSubDocumentOrAddAsSource(RelTable relTable) throws ConversionException {
        var compatibleTable = findCompatibleTableForSubDocument(relTable.documentDTO(), relTable.fieldName());
        if (compatibleTable == null)
            makeTableFromSubDocument(relTable.documentDTO(), relTable.tableName(), relTable.fk());
        else addSubDocumentAsSource(compatibleTable, relTable.documentDTO(), relTable.fk());
    }

    protected void makeTableFromDocument(MongoDBDocumentDTO documentDTO) throws ConversionException {
        var documentId = documentDTO.getDocument().get(DOC_ID_COLUMN_NAME);
        var collectionName = documentDTO.getMongoDBCollectionDTO().getName();
        var tableName = collectionName + NAME_DELIMITER + documentId;
        initTable(documentDTO, tableName);
    }

    protected void makeTableFromSubDocument(MongoDBDocumentDTO subDocumentDTO, String tableName, PostgreSQLForeignKeyDTO fk)
            throws ConversionException {
        var table = initRelTable(subDocumentDTO, tableName, fk);
        var fieldDTO = new PostgreSQLFieldDTO(ID_COLUMN_NAME, PKCOLUMN_TYPE, true, false, table);
        fk.setRelField(fieldDTO);
        fieldDTO.setAutogeneratedFlag();
    }

    protected PostgreSQLTableDTO initTable(MongoDBDocumentDTO documentDTO, String tableName) throws ConversionException {
        var table = new PostgreSQLTableDTO(tableName);
        table.addSource(documentDTO);
        tables.add(table);

        addNotFKFields(documentDTO, table);
        addFKFields(documentDTO, table);

        return table;
    }

    protected PostgreSQLTableDTO initRelTable(MongoDBDocumentDTO documentDTO, String tableName, PostgreSQLForeignKeyDTO fk)
            throws ConversionException {
        var table = initTable(documentDTO, tableName);
        fillRelValuesForFK(table, documentDTO, fk);
        return table;
    }

    protected boolean isCompatibleTableForDocument(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        var optionalSource = tableDTO.getSources().stream().findAny();
        if (optionalSource.isEmpty() || !((MongoDBDocumentDTO) optionalSource.get()).getDocument().containsKey(DOC_ID_COLUMN_NAME)) {
            return false;
        }
        var source = (MongoDBDocumentDTO) optionalSource.get();
        var sourceCollectionName = source.getMongoDBCollectionDTO().getName();
        var documentCollectionName = documentDTO.getMongoDBCollectionDTO().getName();
        var tableIsTop = !tableDTO.getSources().stream().filter(s -> {
            var suffix = ((MongoDBDocumentDTO) s).getDocument().get(DOC_ID_COLUMN_NAME).toString();
            return tableDTO.getName().endsWith(suffix);
        }).toList().isEmpty();
        return sourceCollectionName.equals(documentCollectionName) && tableIsTop;
    }

    protected boolean
    isCompatibleTableForSubDocument(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO, String fieldName) {
        var optionalSource = tableDTO.getSources().stream().findAny();
        if (optionalSource.isEmpty()) return false;

        var source = (MongoDBDocumentDTO) optionalSource.get();
        var sourceCollectionName = source.getMongoDBCollectionDTO().getName();
        var documentCollectionName = documentDTO.getMongoDBCollectionDTO().getName();
        return sourceCollectionName.equals(documentCollectionName) && tableDTO.getName().endsWith(fieldName);
    }

    protected void addSubDocumentAsSource(PostgreSQLTableDTO tableDTO,
                                          MongoDBDocumentDTO documentDTO,
                                          PostgreSQLForeignKeyDTO fk) throws ConversionException {
        updateSimilarFields(tableDTO, documentDTO);
        updateNewFields(tableDTO, documentDTO);
        addAsSource(tableDTO, documentDTO);
        fillRelValuesForFK(tableDTO, documentDTO, fk);
    }

    protected void addDocumentAsSource(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO)
            throws ConversionException {
        addAsSource(tableDTO, documentDTO);
    }

    protected void addAsSource(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) throws ConversionException {
        tableDTO.addSource(documentDTO);
        var subDocs = documentDTO.getFields().stream().filter(f -> f.getType().equals(BsonType.DOCUMENT));
        for (var docField : subDocs.toList()) {
            var relTableName = tableDTO.getName() + NAME_DELIMITER + docField.getOriginalName();
            var subDocument = documentDTO.getSubDocuments().get(docField.getOriginalName());
            var relTableDTO = tables.stream().filter(t -> t.getOriginalName().equals(relTableName)).findFirst();
            if (subDocument != null && relTableDTO.isPresent()) {
                createFK(relTableDTO.get(), tableDTO, docField, documentDTO, subDocument, relTableName);
            }
        }
    }

    protected void createFK(PostgreSQLTableDTO relTableDTO, PostgreSQLTableDTO tableDTO,
                            MongoDBFieldDTO docField, MongoDBDocumentDTO documentDTO,
                            MongoDBDocumentDTO subDocument, String relTableName) throws ConversionException {
        var pk = relTableDTO.getFields().stream().filter(PostgreSQLFieldDTO::isPK).findFirst();
        var curField = tableDTO.getFields().stream()
                .filter(f -> f.getOriginalName().equals(getFKFieldName(docField.getOriginalName()))).findFirst();

        if (pk.isPresent() && curField.isPresent()) {
            var fk = new PostgreSQLForeignKeyDTO();
            var relTable = new RelTable(subDocument, relTableName, fk, docField.getOriginalName());
            fillCurValuesForFK(tableDTO, curField.get(), documentDTO, fk);
            fillRelValuesForFK(relTableDTO, subDocument, fk);
            makeTableFromSubDocumentOrAddAsSource(relTable);
        }
    }

    protected PostgreSQLTableDTO findCompatibleTableForDocument(MongoDBDocumentDTO documentDTO) {
        var table = tables.stream()
                .filter(tableDTO -> isCompatibleTableForDocument(tableDTO, documentDTO)).findAny();
        return table.orElse(null);
    }

    protected PostgreSQLTableDTO findCompatibleTableForSubDocument(MongoDBDocumentDTO subDocumentDTO, String fieldName) {
        var table = tables.stream()
                .filter(tableDTO -> isCompatibleTableForSubDocument(tableDTO, subDocumentDTO, fieldName)).findAny();
        return table.orElse(null);
    }

    protected PostgreSQLFieldDTO addFieldDTO(PostgreSQLTableDTO tableDTO, MongoDBFieldDTO fieldDTO) {
        var fieldName = fieldDTO.getOriginalName();
        var fieldType = (BsonType) fieldDTO.getType();
        var convertedType = PostgresSQLTypesConverter.convert(fieldType);

        return new PostgreSQLFieldDTO(fieldName, convertedType, fieldDTO.isId(), false, tableDTO);
    }

    protected RelTable addFKFieldDTO(PostgreSQLTableDTO tableDTO, MongoDBFieldDTO fkFieldDTO) {
        var docFieldName = fkFieldDTO.getOriginalName();
        var fkFieldType = PostgresSQLTypesConverter.convert((BsonType) fkFieldDTO.getType());
        var relTableName = tableDTO.getName() + NAME_DELIMITER + docFieldName;
        var documentDTO = ((MongoDBDocumentDTO) fkFieldDTO.getFieldsKeeperDTO());
        var subDocument = documentDTO.getSubDocuments().get(docFieldName);

        var curField = new PostgreSQLFieldDTO(getFKFieldName(docFieldName), fkFieldType, fkFieldDTO.isId(), true, tableDTO);
        var fk = new PostgreSQLForeignKeyDTO();
        fillCurValuesForFK(tableDTO, curField, documentDTO, fk);
        return new RelTable(subDocument, relTableName, fk, docFieldName);
    }

    protected void fillRelValuesForFK(PostgreSQLTableDTO relTable,
                                      MongoDBDocumentDTO docFieldKeeper,
                                      PostgreSQLForeignKeyDTO fk) {
        relTable.getFields().stream().filter(f -> !f.isFK() && !f.isAutogenerated()).forEach(f -> {
            var val = docFieldKeeper.getDocument().get(f.getOriginalName());
            if (val != null) fk.setRelValue(f, val);
        });
        var pk = relTable.getFields().stream().filter(PostgreSQLFieldDTO::isPK).findFirst();
        pk.ifPresent(fk::setRelField);
    }

    protected void fillCurValuesForFK(PostgreSQLTableDTO curTable,
                                      PostgreSQLFieldDTO curField,
                                      MongoDBDocumentDTO docFieldKeeper,
                                      PostgreSQLForeignKeyDTO fk) {
        fk.setCurField(curField);
        curTable.getFields().stream().filter(f -> !f.isFK() && !f.isAutogenerated()).forEach(f -> {
            var val = docFieldKeeper.getDocument().get(f.getOriginalName());
            if (val != null) fk.setCurValue(f, val);
        });
    }

    protected void addNotFKFields(MongoDBDocumentDTO documentDTO, PostgreSQLTableDTO tableDTO) {
        getDocumentFieldsThatCanBeMapped(documentDTO).filter(f -> !f.getType().equals(BsonType.DOCUMENT))
                .forEach(fieldDTO -> addFieldDTO(tableDTO, fieldDTO));
    }

    protected void addFKFields(MongoDBDocumentDTO documentDTO, PostgreSQLTableDTO tableDTO) throws ConversionException {
        var fields = getDocumentFieldsThatCanBeMapped(documentDTO);
        for (var fieldDTO : fields.filter(f -> f.getType().equals(BsonType.DOCUMENT)).toList()) {
            var relTable = addFKFieldDTO(tableDTO, fieldDTO);
            makeTableFromSubDocumentOrAddAsSource(relTable);
        }
    }

    protected Stream<MongoDBFieldDTO> getDocumentFieldsThatCanBeMapped(MongoDBDocumentDTO documentDTO) {
        return documentDTO.getFields().stream().filter(f -> PostgresSQLTypesConverter.convert((BsonType) f.getType()) != null);
    }

    protected void updateSimilarFields(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        for (var docField : getDocumentFieldsThatCanBeMapped(documentDTO).toList()) {
            var name = docField.getOriginalName();
            var type = PostgresSQLTypesConverter.convert((BsonType) docField.getType());
            var similarFields = getSimilarFields(tableDTO, name, type).toList();
            if (!similarFields.isEmpty()) {
                similarFields.forEach(f -> f.setNewName(getMarkedFieldName(f)));
                var field = addFieldDTO(tableDTO, docField);
                field.setNewName(getMarkedFieldName(field));
            }
        }
    }

    protected void updateNewFields(PostgreSQLTableDTO tableDTO, MongoDBDocumentDTO documentDTO) {
        for (var docField : getDocumentFieldsThatCanBeMapped(documentDTO).toList()) {
            if (docField.getType().equals(BsonType.DOCUMENT)) {
                var name = getFKFieldName(docField.getOriginalName());
                var type = PostgresSQLTypesConverter.convert((BsonType) docField.getType());
                var similarFields = getSimilarFields(tableDTO, name, type);
                var identicalFields = getIdenticalFields(tableDTO, name, type);
                if (identicalFields.toList().isEmpty() && similarFields.toList().isEmpty()) {
                    addFKFieldDTO(tableDTO, docField);
                }
            } else {
                var name = docField.getOriginalName();
                var type = PostgresSQLTypesConverter.convert((BsonType) docField.getType());
                var similarFields = getSimilarFields(tableDTO, name, type);
                var identicalFields = getIdenticalFields(tableDTO, name, type);
                if (identicalFields.toList().isEmpty() && similarFields.toList().isEmpty()) {
                    addFieldDTO(tableDTO, docField);
                }
            }
        }
    }

    protected Stream<PostgreSQLFieldDTO> getFilteredFields(PostgreSQLTableDTO tableDTO, String name) {
        var fieldsExcludeAutogenerated = tableDTO.getFields().stream().filter(f -> !f.isAutogenerated());
        return fieldsExcludeAutogenerated.filter(f -> f.getOriginalName().equals(name) ||
                (f.isFK() && f.getOriginalName().equals(getFKFieldName(name))));
    }

    protected Stream<PostgreSQLFieldDTO> getSimilarFields(PostgreSQLTableDTO tableDTO, String name, PostgreSQLTypes type) {
        var filteredFields = getFilteredFields(tableDTO, name);
        return filteredFields.filter(f -> !f.getType().equals(type));
    }

    protected Stream<PostgreSQLFieldDTO> getIdenticalFields(PostgreSQLTableDTO tableDTO, String name, PostgreSQLTypes type) {
        var filteredFields = getFilteredFields(tableDTO, name);
        return filteredFields.filter(tableField -> tableField.getType().equals(type));
    }
}
